
-notifications gösterimleri için BS in badge leri kullanılabilinir.

-List,Detail vs View ları için daima VM olusturulur.Buralara gereginden fazla Data gönderilmez.
 Örnegin dataabsede Employee modeli var biz bunu Employee leri listelerken kullanmıyoruz.Aksine ViewModel yapıp
 EmployeeListVM gibi sadece Employee modelinden gerekli yerleri burada tutuyoruz.

-Controller a View eklerken bu işi Scaffold ile yapıyorsak ve View Page e de VM tipli bir data geçiriyorsak
 DBContext içinde SQLDB de yeni bir tablo olusturacak DBSet<Model> field ı OTOMATİKMAN
 olusturuluyor.SQL database e ASLA VM tipli Modelden tablo EKLENMEMELİDİR.Çünkü VM li modeller zaten
 varolan tabloların daraltılıp genişletilerek View Pagelerde kullanılan ara Modellerdir.
 O yüzden View PAgeleri Controllerlardan DB Context ve VM girerek Scaffold yaparken DAİMA
 DBContext clası Kontrol edilmelidir.DB Context içinde View Model içeren bir DBSet varsa o satır silinmelidir.

 public DbSet<LeaveAllocationEditVM> LeaveAllocations { get; set; }

 yukarıdaki gibi bir SATIR olamaz.Yoksa VM modelden tablo yapar Database de.

 Controller daki CRUD işlemleri sonrası meyadana gelecek Exception lar 
 ModelState.AddErrorMEssage("err1" , ex.MEssage) ; 
 şeklinde Model ile ilişkilendirilebilinir.

- async fonksiyonlarda awaitable fonksiyonların ların önünde kesinlikle await yaz

-her ViewModel eklendiginde MAPPER class ta hangi tipler arası dönüştürme yapılacagi belirtilmelidir.

-Herhangi bir Repository içinde başka bir Repository de kullanabiliriz.Amaç Karmaşık CRUD işlerini Controler a degil
 BLL e taşımaktır.

 - How To Validate Model IN GENERAL WAY
   Bir Model i ya da ViewModel i IValidatableObject e extend edersek custom validation kodu yazabiliriz.
   Yani [Required],[Range] etc... gibi Attribute ile yazdığımız validation da DAHA FAZALASINI 
   Modeli Bu class a extend edip implemente edilecek Validate Methoduna yazabiliriz.

- EmailSender ı istenen Controllerlardan birine inejct ederek örnegin leave requesti
  bırakan birinin requesti "accept" ya da "reject" edildiginde ona mail gönderilebilinir.
  Veya bu işi Controllerdan ziyade Repository lerde de yapabiliriz.
  Email yollama blockları try-catch içine alındı papercut email service ile test edilebilirler. 

-ApplicationDBContext te SaveChanges methodu override edilerek Save esnasında yapılacak extra işlemler oraya
 yazılabilinir.Öenegin aşagida bütün Entity lerin Base classında Id,DateCREATEd ve DateModified vardır.
 Biz Eğer Entity DB ye ilk defa ekleniyorsa DateCreated ını now yaptık
 Eğer Entity modifiye ediliyorsa da modifiye tarihini girdik.

 public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
        {

            foreach (var entry in base.ChangeTracker.Entries<BaseEntity>().Where(q=>q.State==EntityState.Added || q.State == EntityState.Modified) )
            {
                entry.Entity.DateModified = DateTime.Now;

                if(entry.State == EntityState.Added)
                {
                    entry.Entity.DateCreated = DateTime.Now;
                }
            }


            return base.SaveChangesAsync(cancellationToken);
        }


-Logging konusu işlendi.Logging Error ları track etmek için kullanılır.
 Logging için Serilog kütüphanesi kullanılacak.

1. appsettings.json da Logging kısmı Serilog ile degistirilir
2. Program.cs e aşagidaki satır eklenir
    builder.Host.UseSerilog((ctx, lc) =>
    {
    lc.WriteTo.Console().ReadFrom.Configuration(ctx.Configuration);  
   
    });

Bu şekilde hata mesajları Consola yazdırılır. ctx.Configuration ile
appsettings.json daki Serilog la ilgili ayarlar kullanılır.

3.Middleware kısmına aşagidaki satır eklenir.

var app = builder.Build();
app.UseSerilogRequestLogging(); 

-Seperation Of Concern  (Solid deki S)
 Projeyi tek fiziksel parçalara böleriz Data ve repository ile ilgili kısımları ayrı bir
 class librarye yazarız.
